"""A module for separating solid phase from liquid tracers using image processing techniques."""

__licence__ = """
Copyright (C) 2011  www.openpiv.net

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""


import numpy as np
import scipy.ndimage
try:
    import cv2
except ImportError as e:
    raise Exception(
        "Opencv Not Found.\n"
        "This functionality requires python OpenCV module to be installed.\n"
        "On Ubuntu use 'sudo apt install python3-opencv'\n") from e


def opening_method( original_image, kernel_size, iterations=1, masking_thresh=10 ):
    """Extract separated images based on particle size.

    This method uses an *erosion* filter followed by a *dilation* (aka *opening*), to remove
    small particle traces, leaving only bigger particles in the image.

    The image of small particles is also generated by using the big particles
    image as a mask on the original image. A threshold process is used to 
    intensify the edges of particles in the mask.

    Use this filter only if there is no background light in the image. If
    background is not completely black, black holes will appear in the
    image of carrier particles which may invalidate the follow up PIV process.

    TODO: Replace black holes with neutral noise to avoid a back-flow effect, especially in images with non-black background.

    Parameters
    ----------
    original_image : np.ndarray
        Original two-phase input image

    kernel_size : int
        Erosion/dilation stencil width

    iterations : int
        Erosion iterations, default = 1

    masking_thresh : int
        Used to enhance mask edge (between 0-255), default = 10.
        This removes the glow that would otherwise be left around big particles black hole.


    Returns
    -------
    big_particles_img : np.ndarray
        Extracted image of the phase with bigger particles (dispersed phase)

    small_particles_img : np.ndarray
        Extracted image of the phase with smaller particles (carrier phase)

    """

    kernel = cv2.getStructuringElement( cv2.MORPH_ELLIPSE, (kernel_size, kernel_size) )
    eroded_image = cv2.erode( original_image, kernel, iterations=iterations )
    big_particles_img = cv2.dilate( eroded_image, kernel, iterations=iterations )
    
    _, mask = cv2.threshold( big_particles_img, masking_thresh, 1, cv2.THRESH_BINARY_INV )
    small_particles_img = cv2.multiply( original_image, mask )

    return big_particles_img, small_particles_img


def median_filter_method(original_image, kernel_size):
    """Extract separated images using a median filter
    
    Proposed by Kiger & Pan. Original paper:

    Kiger, K. T., & Pan, C. (2000). PIV technique for the simultaneous measurement of dilute two-phase flows.
    *Journal of Fluids Engineering, Transactions of the ASME,* 122(4), 811–818.
    https://doi.org/10.1115/1.1314864

    Parameters
    ----------
    original_image : np.ndarray
        Original two-phase input image
    
    kernel_size : int
        Filter stencil width (must be an odd number). Denoted by *Nf* in Kiger & Pan.

    Returns
    -------
    big_particles_img : np.ndarray
        Extracted image of the phase with bigger particles (dispersed phase)

    small_particles_img: np.ndarray
        Extracted image of the phase with smaller particles (carrier phase)
    """

    if (kernel_size % 2 != 1):
        raise Exception("kernel_size must be an odd number.")

    big_particles_img = cv2.medianBlur( original_image, kernel_size )
    small_particles_img = cv2.subtract( original_image, big_particles_img )

    return big_particles_img, small_particles_img


def khalitov_longmire(original_image, big_particles_criteria, small_particles_criteria, blur_kernel_size=1, I_sat=230, opening_ksize=3):
    """Extract separated images using the method proposed by Khalitov & Longmire, 2002.
    
    For detailed information see:

    Khalitov, D., Longmire, E. Simultaneous two-phase PIV by two-parameter phase discrimination.
    *Experiments in Fluids* 32, 252–268 (2002).
    https://doi.org/10.1007/s003480100356

    Parameters
    ----------
    original_image : np.ndarray
        Original two-phase input image
    
    big_particles_criteria : {
        'min_size' : int,
        ['max_size' : int,]
        ['min_brightness' : int,]
        ['max_brightness' : int]
    }
    A dictionary defining big particles criteria. 'min_size' is mandatory.

    small_particles_criteria : {
        ['min_size' : int,]
        'max_size' : int,
        ['min_brightness' : int,]
        ['max_brightness' : int]
    }
    A dictionary defining small particles criteria. 'max_size' is mandatory.

    blur_kernel_size : int
        Stencil width for pre-processing blur. Must be an odd number.

    I_sat : int
        Saturation intensity for object pixels detection process.

    opening_ksize : int
        Stencil width for opening operation used to remove tiny regions from object pixels.

    Returns
    -------
    big_particles_img : np.ndarray
        Extracted mask image of the phase with bigger particles (dispersed phase)

    small_particles_img : np.ndarray
        Extracted mask image of the phase with smaller particles (carrier phase)
    """
    # Calculate object pixels using 2nd derivative criteria
    object_pixels = khalitov_longmire_get_object_pixels(original_image, blur_kernel_size, I_sat, opening_ksize)

    # Find connected components & corresponding data
    N, labels_image, regions_size_array, regions_brightness_array = khalitov_longmire_analyse_particle_segments(original_image, object_pixels)

    # Apply criteria to regions

    ## Big particles
    is_region_a_big_particle = (regions_size_array > big_particles_criteria['min_size'])

    if 'max_size' in big_particles_criteria:
        is_region_a_big_particle &= (regions_size_array < big_particles_criteria['max_size'])

    if 'min_brightness' in big_particles_criteria:
        is_region_a_big_particle &= (regions_brightness_array > big_particles_criteria['min_brightness'])

    if 'max_brightness' in big_particles_criteria:
        is_region_a_big_particle &= (regions_brightness_array < big_particles_criteria['max_brightness'])

    ## Small particles
    is_region_a_small_particle = (regions_size_array < small_particles_criteria['max_size'])

    if 'min_size' in small_particles_criteria:
        is_region_a_small_particle &= (regions_size_array > small_particles_criteria['min_size'])

    if 'min_brightness' in small_particles_criteria:
        is_region_a_small_particle &= (regions_brightness_array > small_particles_criteria['min_brightness'])

    if 'max_brightness' in small_particles_criteria:
        is_region_a_small_particle &= (regions_brightness_array < small_particles_criteria['max_brightness'])

    # Generate big particles image
    big_particles_img = np.zeros(original_image.shape, dtype=np.uint8)
    for i in range(0, N):
        if is_region_a_big_particle[i]:
            big_particles_img[ labels_image == i ] = 255

    # Generate unidentifed particles image (for efficiency reasons)
    unindentified_particles_img = np.zeros(original_image.shape, dtype=np.uint8)
    for i in range(0, N):
        if (not is_region_a_big_particle[i]) and (not is_region_a_small_particle[i]):
            unindentified_particles_img[ labels_image == i ] = 255

    # Generate small particles image
    small_particles_img = object_pixels - big_particles_img - unindentified_particles_img

    return big_particles_img, small_particles_img


def get_particles_size_array(original_image, blur_kernel_size=1, I_sat=230, opening_ksize=3):
    """Returns the array of particle image areas in pixels.

    Used as a quick means to set size limits in Kalitov-Longmire method.

    Usage Example:

        plt.hist( get_particles_size_array(image) )
        plt.title('Particle size distribution')

    Parameters
    ----------
    original_image : np.ndarray
        Original two-phase input image

    blur_kernel_size : int
        Stencil width for pre-processing blur. Must be an odd number.

    I_sat : int
        Saturation intensity for object pixels detection process.

    opening_ksize : int
        Stencil width for opening operation used to remove tiny regions from object pixels.

    Returns
    -------
    size_array : np.array
        Array of length N, containing areas of particle regions number 0 to N in pixels.
    """
    # Calculate object pixels using 2nd derivative criteria
    object_pixels = khalitov_longmire_get_object_pixels(original_image, blur_kernel_size, I_sat, opening_ksize)

    # Find connected components & corresponding data
    _, _, size_array, _ = khalitov_longmire_analyse_particle_segments(original_image, object_pixels)

    return size_array


def get_size_brightness_map(original_image, blur_kernel_size=1, I_sat=230, opening_ksize=3, MAX_PARICLE_SIZE=400):
    """Returns the size-brightness map.

    Used as an advanced means to set size and brightness limits in Kalitov-Longmire method.

    Usage Example:

        plt.imshow(im, origin='lower')
        plt.xlabel('Brightness')
        plt.ylabel('Size (px)')
        plt.title('Signal density')

    Parameters
    ----------
    original_image : np.ndarray
        Original two-phase input image

    blur_kernel_size : int
        Stencil width for pre-processing blur. Must be an odd number.

    I_sat : int
        Saturation intensity for object pixels detection process.

    opening_ksize : int
        Stencil width for opening operation used to remove tiny regions from object pixels.

    MAX_PARICLE_SIZE : int
        Particle area upper limit (Y-axis max in the map) in pixels.

    Returns
    -------
    density_map : np.ndarray
        Density map (D) where D[i,j] is log10(size*brightness*number) at size=i & brightness=j.
        See Kalitov & Longmire, 2002 for more information.
    """
    # n[i,j] = Number of particles with size of i and rounded brightness of j
    n = np.zeros((MAX_PARICLE_SIZE, 255), dtype=int)

    # Get Object Pixels
    object_pixels = khalitov_longmire_get_object_pixels(original_image, blur_kernel_size, I_sat, opening_ksize)
    
    # Find connected components & corresponding data
    N, _, size_array, brightness_array = khalitov_longmire_analyse_particle_segments(original_image, object_pixels)

    # Round brightness
    rounded_brightness = np.uint8(np.round(brightness_array))

    # Count size-brightness
    for i in range(0, N):
        if size_array[i] >= MAX_PARICLE_SIZE:
            continue
        n[size_array[i], rounded_brightness[i]] += 1

    # Calculate total signal density map:
    SIZE, BRIGHTNESS = np.meshgrid(range(0, 255), range(0, MAX_PARICLE_SIZE))
    with np.errstate(divide='ignore'):
        density_map = np.log10(SIZE * BRIGHTNESS * n)
    density_map[ np.isneginf(density_map) ] = 0

    return density_map


def khalitov_longmire_analyse_particle_segments(original_image, object_pixels):
    """Private function"""    
    # Find connected components
    N, labels, stats, _ = cv2.connectedComponentsWithStats(object_pixels)

    # Area of each region is reported in the 5th column
    size_array = stats[:,4]

    # Integrate intensity over regions
    total_light_array = scipy.ndimage.sum(original_image, labels, index=range(0, N))
    brightness_array = total_light_array / size_array

    # Drop background region (index 0)
    return N-1, labels-1, size_array[1:], brightness_array[1:]


def khalitov_longmire_get_object_pixels(original_image, blur_kernel_size=1, I_sat=230, opening_ksize=3):
    """Private function"""
    if (blur_kernel_size % 2 != 1):
        raise Exception("Blur kernel size must be an odd number.")

    # Pre-processing box blur
    if blur_kernel_size > 0:
        original_image = cv2.blur(original_image, (blur_kernel_size, blur_kernel_size))
    
    # Transform to log space
    I = np.float32(original_image)
    Ln_I = cv2.log(I)

    # Calculate second directional derivatives
    X_deriv2 = cv2.filter2D(Ln_I, -1, np.asarray([
        [0, 0, 0],
        [1, -2, 1],
        [0, 0, 0]
    ]))
    Y_deriv2 = cv2.filter2D(Ln_I, -1, np.asarray([
        [0, 1, 0],
        [0, -2, 0],
        [0, 1, 0]
    ]))
    D45_deriv2 = cv2.filter2D(Ln_I, -1, np.asarray([
        [0, 0, 1],
        [0, -2, 0],
        [1, 0, 0]
    ])) # 0.707 coeff is ignored as we're only interested in sign of the result.
    D135_deriv2 = cv2.filter2D(Ln_I, -1, np.asarray([
        [1, 0, 0],
        [0, -2, 0],
        [0, 0, 1]
    ])) # 0.707 coeff is ignored as we're only interested in sign of the result.

    # Apply conditions for object pixels
    object_pixels = ( (X_deriv2 < 0) & (Y_deriv2 < 0) & (D45_deriv2 < 0) & (D135_deriv2 < 0) ) | (I > I_sat)
    object_pixels_uint8 = 255 * np.uint8(object_pixels)

    # Apply opening filter to remove noisy dots
    kernel = cv2.getStructuringElement( cv2.MORPH_ELLIPSE, (opening_ksize, opening_ksize) )
    object_pixels_uint8 = cv2.morphologyEx(object_pixels_uint8, cv2.MORPH_OPEN, kernel)

    return object_pixels_uint8
